<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">

    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ODE Simulator</title>
    <link rel="stylesheet" href="https://unpkg.com/papercss@1.9.2/dist/paper.min.css" />
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.js"></script>
    <style>
        textarea {
            width: 100%;
            height: 100px;
        }

        #plot {
            width: 100%;
            height: 400px;
        }
    </style>
</head>

<body>

    <div class="paper container">
    <h1>ODE Simulator</h1>
    <div>
        <h2>Enter ODE equations:</h2>
        <textarea id="ode-input" placeholder="Enter ODE equations, one per line. For example:
dx/dt = -y*a
dy/dt = -x*b"></textarea>
    </div>
    <div class="row flex-spaces"><div id="warning" class="alert alert-danger" style="visibility: hidden;"></div></div>
    <div id="inputs"></div>
    <div class="row">
        <div class="col col-4"><label for="n-steps">Number of steps:</label></div>
        <div class="col col-4"><input type="number" id="n-steps" value="1000" min="100" max="10000" step="100"></div>
    </div>
    <button id="solve-btn">Solve</button>
    <div id="plot"></div>
    </div>
    <script>
        const odeInput = document.getElementById('ode-input');
        const warningDiv = document.getElementById('warning');
        const inputsDiv = document.getElementById('inputs');
        const solveBtn = document.getElementById('solve-btn');
        const plotDiv = document.getElementById('plot');

        let equations = [];
        let variables = [];
        let parameters = [];
        let independentVar = '';

        odeInput.addEventListener('input', parseEquations);
        solveBtn.addEventListener('click', solve);

        function updateInputs() {
            inputsDiv.innerHTML = '';

            // Independent variable range
            const indepVarGroup = createInputGroup('\'' + independentVar + '\' range', 'range', independentVar, [0, 10]);
            inputsDiv.appendChild(indepVarGroup);

            // Initial conditions for variables
            variables.forEach(variable => {
                const varGroup = createInputGroup('\'' + variable + '\' initial value', 'number', variable, 1);
                inputsDiv.appendChild(varGroup);
            });

            // Parameter inputs and sliders
            parameters.forEach(param => {
                const paramGroup = createInputGroup('\'' + param + '\' range', 'range', param, [-1, 2]);
                inputsDiv.appendChild(paramGroup);

                const sliderGroup = document.createElement('div');
                sliderGroup.className = 'form-group row';
                sliderGroup.innerHTML = `
                    <div class="col col-4"><label for="${param}-slider">'${param}' value:</label></div>
                    <div class="col col-4"><input type="range" id="${param}-slider" min="-1" max="2" step="0.01" value="1"></div>
                    <div class="col col-4"><output id="${param}-value" for="${param}-slider">1</output></div>
                `;
                inputsDiv.appendChild(sliderGroup);

                const slider = sliderGroup.querySelector(`#${param}-slider`);
                const valueSpan = sliderGroup.querySelector(`#${param}-value`);
                const rangeMin = paramGroup.querySelector(`#${param}-min`);
                const rangeMax = paramGroup.querySelector(`#${param}-max`);

                slider.addEventListener('input', () => {
                    valueSpan.textContent = parseFloat(slider.value).toFixed(2);
                    if (plotDiv.innerHTML) solve();
                });

                [rangeMin, rangeMax].forEach((rangeBnd) => rangeBnd.addEventListener('input', () => {
                    const min = parseFloat(document.getElementById(`${param}-min`).value);
                    const max = parseFloat(document.getElementById(`${param}-max`).value);
                    slider.min = min;
                    slider.max = max;
                    slider.value = Math.min(max, Math.max(min, slider.value));
                    valueSpan.textContent = parseFloat(slider.value).toFixed(2);
                    if (plotDiv.innerHTML) solve();
                }));
            });
        }

        function createInputGroup(label, type, name, defaultValue) {
            const group = document.createElement('div');
            group.className = 'form-group row';
            group.innerHTML = `
            <div class="col col-4"><label for="${name}-input">${label}:</label></div>
                ${type === 'range'
                    ? `<div class="col col-4"><input type="number" id="${name}-min" value="${defaultValue[0]}" step="0.1"></div>
                       <div class="col col-4"><input type="number" id="${name}-max" value="${defaultValue[1]}" step="0.1"></div>`
                    : `<div class="col col-4"><input type="${type}" id="${name}-input" value="${defaultValue}" step="0.1"></div>`
                }
            `;
            return group;
        }
        // Add this to the global variables at the top
        let nSteps = 1000;

        function parseEquations() {
            const input = odeInput.value.trim();
            equations = input.split('\n').map(eq => eq.trim()).filter(eq => eq);
            variables = [];
            parameters = [];
            independentVar = '';

            const vars = new Set();
            const indepVars = new Set();

            // First pass: identify variables and independent variables
            equations.forEach(eq => {
                const [lhs, rhs] = eq.split('=').map(side => side.trim());
                const match = lhs.match(/d(\w+)\/d(\w+)/);
                if (match) {
                    vars.add(match[1]);
                    indepVars.add(match[2]);
                }
            });

            variables = Array.from(vars);

            if (indepVars.size > 1) {
                warningDiv.textContent = 'Warning: Equations have different independent variables.';
                warningDiv.style.visibility = 'visible';
            } else if (indepVars.size === 1) {
                independentVar = Array.from(indepVars)[0];
                warningDiv.textContent = '';
                warningDiv.style.visibility = 'hidden';
            } else {
                warningDiv.textContent = 'Error: No independent variable found.';
                warningDiv.style.visibility = 'visible';
                return;  // Exit the function if no independent variable is found
            }

            // Second pass: identify parameters
            const allSymbols = new Set();
            equations.forEach(eq => {
                const [, rhs] = eq.split('=').map(side => side.trim());

                try {
                    const symbols = math.parse(rhs).filter(node => node.isSymbolNode).map(node => node.name);
                    symbols.forEach(symbol => allSymbols.add(symbol));
                } catch (e) {
                    warningDiv.textContent = 'Warning: Cannot parse equations (yet).';
                warningDiv.style.visibility = 'visible';
                }
            });

            parameters = Array.from(allSymbols).filter(symbol =>
                !vars.has(symbol) && symbol !== independentVar
            );

            updateInputs();
        }

        function solve() {
            const tMin = parseFloat(document.getElementById(independentVar + '-min').value);
            const tMax = parseFloat(document.getElementById(independentVar + '-max').value);
            nSteps = parseInt(document.getElementById('n-steps').value);
            const initialConditions = {};
            variables.forEach(variable => {
                initialConditions[variable] = parseFloat(document.getElementById(variable + '-input').value);
            });
            const paramValues = {};
            parameters.forEach(param => {
                paramValues[param] = parseFloat(document.getElementById(param + '-slider').value);
            });

            const solution = rungeKutta(equations, variables, paramValues, independentVar, initialConditions, tMin, tMax);

            const traces = variables.map(variable => ({
                x: solution.map(point => point[independentVar]),
                y: solution.map(point => point[variable]),
                mode: 'lines',
                name: variable
            }));

            const layout = {
                title: 'ODE Solution',
                xaxis: {
                    title: independentVar,
                    tickformat: `.${Math.max(0, -Math.floor(Math.log10(tMax)) + 2)}f`
                },
                yaxis: { title: 'Value' }
            };

            Plotly.newPlot(plotDiv, traces, layout);
        }

        function rungeKutta(equations, variables, parameters, independentVar, initialConditions, tMin, tMax) {
            const h = (tMax - tMin) / nSteps;
            const solution = [{ [independentVar]: tMin, ...initialConditions }];

            const compiledEquations = equations.map(eq => {
                const [, rhs] = eq.split('=').map(side => side.trim());
                return math.compile(rhs);
            });

            for (let t = tMin; t < tMax; t += h) {
                const current = solution[solution.length - 1];
                const k1 = calculateK(compiledEquations, current, parameters, h);
                const k2 = calculateK(compiledEquations, addK(variables, current, k1, 0.5), parameters, h);
                const k3 = calculateK(compiledEquations, addK(variables, current, k2, 0.5), parameters, h);
                const k4 = calculateK(compiledEquations, addK(variables, current, k3, 1), parameters, h);

                const next = { [independentVar]: t + h };
                variables.forEach((variable, i) => {
                    next[variable] = current[variable] + (k1[i] + 2 * k2[i] + 2 * k3[i] + k4[i]) / 6;
                });
                solution.push(next);
            }

            return solution;
        }

        function calculateK(equations, point, parameters, h) {
            return equations.map(eq => h * eq.evaluate({ ...point, ...parameters }));
        }

        function addK(variables, point, k, factor) {
            const result = { ...point };
            variables.forEach((key, i) => {
                if (key !== independentVar) {
                    result[key] += factor * k[i];
                }
            });
            return result;
        }

    </script>
</body>

</html>